//AR contains: previous ARP, return address, num, base, return value (in that order)


start:           loadI 0 => r_zero
                 push r_zero                            //return value

                 in "Number? " => r_num
                 in "Base? " => r_base

                 push r_base
                 push r_num

                 loadI #end => r_addr
                 push r_addr                            // return address

convert:         div r_num, r_base => r_rest
                 mult r_base, r_rest => r_temp
                 sub r_num, r_temp => r_temp
                 out "Next digit: ", r_temp

                 cmp_EQ r_rest, r_zero => r_if
                 cbr r_if -> then, else

then:            loadI 1 => r_result

else:            push r_zero                        //result
                 push r_base
                 push r_rest                        //new value for num
                 loadI #return => r_temp
                 push r_temp                        //return address
                 push r_arp
                 subI r_arp, 20 => r_arp            //new arp, one before the current one
                 jumpI -> convert                   // recursive call

return:         loadAI r_arp,-4 => r_result
                addI r_result, 1 => r_result

end_then:        pop => r_arp
                 pop => r_address
                 pop => r_null
                 pop => r_null
                 push r_result
                 jumpI -> r_address

end:            loadAI r_arp, -4 => r_result
                out "Length: ", r_result
